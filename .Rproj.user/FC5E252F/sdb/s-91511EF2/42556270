{
    "contents" : "##########################################################################################\n#                                                                                        #\n#  Suite of functions for analyzing price to rent ratios in Australia                    #\n#                                                                                        #\n##########################################################################################\n\n### Function to convert various APM date structures into R date structure ----------------\n\nfixAPMDates <- function(xDates      # Vector of dates to be fixed\n                        )\n  {\n  \n ## Set required libraries\n  \n  require(stringr)\n\n ## Break down dates\n  \n  # Remove Time\n  xDates <- gsub(\" 0:00\", \"\", xDates)\n  \n  # Find location of slashes\n  sLoc <- matrix(unlist(str_locate_all(xDates, '/')), ncol=4, byrow=TRUE)[,1:2]\n  \n  # Correct Days\n  days <- as.numeric(substr(xDates, 1, sLoc[ ,1] - 1))\n  days <- ifelse(days < 10, paste0('0', days), as.character(days))\n    \n  # Correct Months\n  months <- as.numeric(substr(xDates, sLoc[ ,1] + 1, sLoc[ ,2] - 1))\n  months <- ifelse(months < 10, paste0('0', months), as.character(months))\n  \n  # Correct years\n  years <- as.numeric(substr(xDates, sLoc[ ,2] + 1, 50))\n  years <- ifelse(years < 2000, paste0('20', years), as.character(years))\n\n ## Recombine into R date format  \n    \n  newDates <- as.Date(paste0(days, '/' , months, '/', years), \"%d/%m/%Y\")\n\n ## Return Values  \n  \n  return(newDates)\n}\n\n### Regression function that creates imputed rent and sales values -----------------------\n\nprrImputeReg <- function(formula,               # LM regression formula\n                         saleData,              # Data containing sales\n                         rentData,              # Data containing rentals\n                         verbose = FALSE        # Show progress?\n                         ){\n  \n ## Estimate models and make new predictions\n  \n  # Esimate models\n  if(verbose) cat('Estimating sale and rent models\\n')\n  saleModel <- lm(formula, data=saleData)\n  rentModel <- lm(formula, data=rentData)\n  \n  # Make predictions of imputed values\n  if(verbose) cat('Imputing values\\n')\n  impPrice <- exp(predict(saleModel, newdata=rentData))\n  impRent <- exp(predict(rentModel, newdata=saleData))\n  \n  # Apply cross values\n  if(verbose) cat('Stacking observed and imputed values\\n')\n  saleData$Price <- saleData$transValue\n  rentData$Price <- impPrice\n  saleData$Rent <- impRent\n  rentData$Rent <- rentData$transValue\n  \n  # Combine data back together\n  if(verbose) cat('Merging data\\n')\n  allData <- rbind(saleData, rentData)\n\n  ## Extract model information\n  saleModelInfo <- list(coef=summary(saleModel)$coefficients,\n                        r2=summary(saleModel)$r.squared,\n                        sigma=summary(saleModel)$r.squared,\n                        resid=summary(saleModel)$residuals)\n  rentModelInfo <- list(coef=summary(rentModel)$coefficients,\n                        r2=summary(rentModel)$r.squared,\n                        sigma=summary(rentModel)$r.squared,\n                        resid=summary(rentModel)$residuals)\n  \n  \n  \n ## Return values\n  return(list(results = allData[ ,c('UID', 'Price', 'Rent')],\n              saleModel = saleModelInfo,\n              rentModel = rentModelInfo))\n         \n}\n\n### Function to determine which geo areas meet use and time criteria ---------------------\n\nprrGeoLimit <- function(transData,               # Dataframe of trans data\n                        locField = 'locName',    # Field containing location\n                        timeField = 'transYear', # Field containing time\n                        geoTempLimit = 3         # Min trans per use/time/loc\n){  \n  \n  # Split transactions by use\n  houseSales <- subset(transData, PropertyType == 'House' &\n                         transType == 'sale')\n  unitSales <- subset(transData, PropertyType == 'Unit' & \n                        transType == 'sale')\n  houseRentals <- subset(transData, PropertyType == 'House' & \n                           transType == 'rent')\n  unitRentals <- subset(transData, PropertyType == 'Unit' & \n                          transType == 'rent')\n  \n  # Determine which suburbs meet criteria for each\n  saleHTable <- table(houseSales[,locField], houseSales[,timeField])\n  shKeep <- which(apply(saleHTable, 1, min) >= geoTempLimit)\n  shGeo <- rownames(saleHTable[shKeep, ])\n  saleUTable <- table(unitSales[,locField], unitSales[,timeField])\n  suKeep <- which(apply(saleUTable, 1, min) >= geoTempLimit)\n  suGeo <- rownames(saleUTable[suKeep, ])\n  rentHTable <- table(houseRentals[,locField], houseRentals[,timeField])\n  rhKeep <- which(apply(rentHTable, 1, min) >= geoTempLimit)\n  rhGeo <- rownames(rentHTable[rhKeep, ])\n  rentUTable <- table(unitRentals[,locField], unitRentals[,timeField])\n  ruKeep <- which(apply(rentUTable, 1, min) >= geoTempLimit)\n  ruGeo <- rownames(rentUTable[ruKeep, ])\n  bothGeo <- intersect(intersect(intersect(shGeo, suGeo), rhGeo), ruGeo)\n  houseGeo <- intersect(shGeo,rhGeo)\n  unitGeo <- intersect(suGeo, ruGeo)\n  eitherGeo <- union(houseGeo, unitGeo)\n  \n  # Create tables\n  return(list(bothGeo = bothGeo,\n              houseGeo = houseGeo,\n              unitGeo = unitGeo,\n              eitherGeo = eitherGeo))  \n}\n\n### Apply the threshold designations across all transactions -----------------------------\n\nprrApplyThres <- function(thresData,       # Threshold data object from prrGeoLimit\n                          transData,       # Set of transaction data\n                          timePrefix='YT', # Which time was used YT or QT\n                          geo=\"postCode\"   # Which geo to use (one at a time)\n                          ){\n  \n  # Pull out single designations\n  both <- ifelse(transData[,geo] %in% thresData[[1]],1,0)\n  house <- ifelse(transData[,geo] %in% thresData[[2]],1,0)\n  unit <- ifelse(transData[,geo] %in% thresData[[3]],1,0)\n  either <- ifelse(transData[,geo] %in% thresData[[4]],1,0)\n  \n  # Combine them\n  all <- as.data.frame(cbind(both, house, unit, either))\n  \n  # Rename\n  names(all) <- paste0(timePrefix, \"_\", names(all), \"_\",geo)\n  \n  # Add to existing transactions\n  return(cbind(transData, all))\n}\n\n##########################################################################################\n### New Australia Rent Yield Functions (works with stShard operations) -------------------\n\nprrStsGeoWrap <- function(stsData,                    # Observation data frame\n                          metrics,                    # Field(s) to calculate on\n                          spaceField,                 # Field with space variable or 'all'\n                          timeField,                  # Field with time variable\n                          defDim='time',              # 'Space' or 'Time' as dimension\n                          stsLimit,                   # Nbr of obs required per shard\n                          calcs=list(median='median') # Type of calculation to do\n                          ){\n  \n  ## Source stshard functions if not already done\n  if(!exists('spaceTimeShard')) {\n    source(paste0('https://raw.githubusercontent.com/andykrause/',\n                  'dataAnalysisTools/master/stShardFunctions.R'))\n  }\n  \n  \n  ## Calculate prices and rents\n  \n  xPrice <- spaceTimeShard(stsData[stsData$transType == 'sale', ],\n                           metric=metrics[1], spaceField=spaceField,\n                           timeField=timeField, defDim=defDim, \n                           stsLimit=stsLimit, calcs=calcs)\n  \n  xRent <- spaceTimeShard(stsData[stsData$transType == 'rent', ],\n                          metric=metrics[2], spaceField=spaceField,\n                          timeField=timeField, defDim=defDim, \n                          stsLimit=stsLimit, calcs=calcs)\n  \n  ## If not doing all spatial areas\n  \n  if(spaceField != 'all'){\n  \n  # Trim results to geographies with both prices and rents  \n    okNames <- intersect(names(xPrice[[2]]), names(xRent[[2]]))\n    geoPrices <- xPrice[[4]]\n    geoPrices <- geoPrices[geoPrices$spaceName %in% okNames,]\n    geoRents <- xRent[[4]]\n    geoRents <- geoRents[geoRents$spaceName %in% okNames,]\n  \n  # Convert to exportable table\n    geoTable <- data.frame(timeName=geoPrices$timeName,\n                           spaceName=geoPrices$spaceName,\n                           price=geoPrices$median,\n                           rent=geoRents$median,\n                           yield=(geoRents$median * 52) / geoPrices$median)\n  } else {\n    \n    geoTable <- data.frame(timeName=xPrice$stsDF$timeName,\n                           spaceName='all',\n                           price=xPrice$stsDF$median,\n                           rent=xRent$stsDF$median,\n                           yield=((xRent$stsDF$median * 52) / \n                             xPrice$stsDF$median))\n    \n  }\n    \n  ## Export data  \n  \n  return(list(stsDF=geoTable,\n              priceStsTable=xPrice$stTable,\n              rentStsTable=xRent$stTable))\n}\n\n### Function to compare price and rent on only matched properties ------------------------\n\nprrSaleRentMatch <- function(sales,               # Data.frame of sales\n                             rentals,             # Data.frame of rentals\n                             matchField = 'ID',   # Field containing matching ID\n                             saleField = 'Price', # Field containing sale price\n                             rentField = 'Rent',  # Field containing rent \n                             timeField = 'Year'   # Field containing time breakdown\n){\n\n  ## Matching sales to rentals\n  \n  # Remove NAs in matchField\n  xSales <- subset(sales, !is.na(sales[matchField]))\n  xRentals <- subset(rentals, !is.na(rentals[matchField]))\n\n  # Sort to order\n  xSales <- xSales[order(xSales[,matchField]),]\n  xRentals <- xRentals[order(xRentals[,matchField]),]\n  \n  # Extract matching field\n  sMatch <- xSales[ ,matchField]\n  rMatch <- xRentals[ ,matchField]\n  \n  # Perform cross match identification\n  mSales <- xSales[!is.na(match(sMatch, rMatch)), ]\n  mRentals <- xRentals[!is.na(match(rMatch, sMatch)), ]\n  \n  # Make the match\n  mTrans <- merge(mSales[, c(matchField, saleField, timeField)],\n                  mRentals[, c(matchField, rentField, timeField)],\n                  by=matchField)\n  \n  # Rename Match Fields\n  names(mTrans) <- c(matchField, 'saleValue', 'saleTime', 'rentValue', 'rentTime')\n  \n  ## Make time adjustments to matched transactions\n  \n  # Create the rent index\n  rentTrend <- as.numeric(tapply(mTrans$rentValue, mTrans$rentTime, median))\n  rentIndex <- rentTrend / rentTrend[1]\n  \n  # Create the sale index\n  saleTrend <- as.numeric(tapply(mTrans$saleValue, mTrans$saleTime, median))\n  saleIndex <- saleTrend / saleTrend[1]\n  \n  # Make the adjustments to the rentals\n  rentAdj <- (rentIndex[as.numeric(as.factor(mTrans$saleTime))] /\n                rentIndex[as.numeric(as.factor(mTrans$rentTime))])\n  mTrans$adjRent <- mTrans$rentValue * rentAdj\n  \n  # Make the adjustments to the sales\n  saleAdj <- (saleIndex[as.numeric(as.factor(mTrans$rentTime))] /\n                saleIndex[as.numeric(as.factor(mTrans$saleTime))])\n  mTrans$adjSale <- mTrans$saleValue * saleAdj\n  \n  # Calc Yields\n  mTrans$saleYield <- (mTrans$adjRent * 52) / mTrans$saleValue\n  mTrans$rentYield <- (mTrans$rentValue * 52) / mTrans$adjSale\n  \n ## Add Location variables\n  \n  mTrans$lga <- xSales$lga[match(mTrans$AddressID, xSales$AddressID)]\n  mTrans$sla1 <- xSales$sla1[match(mTrans$AddressID, xSales$AddressID)]\n  mTrans$suburb <- xSales$suburb[match(mTrans$AddressID, xSales$AddressID)]\n  mTrans$postCode <- xSales$postCode[match(mTrans$AddressID, xSales$AddressID)]\n  mTrans$latitude <- xSales$Property_Latitude[match(mTrans$AddressID, \n                                                    xSales$AddressID)]\n  mTrans$longitude <- xSales$Property_Longitude[match(mTrans$AddressID, \n                                                      xSales$AddressID)]\n  mTrans$PropertyType <- xSales$PropertyType[match(mTrans$AddressID, \n                                                   xSales$AddressID)]\n\n  ## Return Values    \n  return(mTrans)  \n}  \n\n## Function to aggregate data by geography -----------------------------------------------\n\nprrAggrGeoData <- function(geoList,         # List of sharded results (9 total)\n                           indexList,       # List of price indexes (all, house, unit)\n                           geoSplit=FALSE   # Using a geo smaller than all area?\n){\n  \n  \n  ## Build Mixed unweighted\n    \n  mixData <- prrAggrMethData(mmObj=geoList$mm$all,\n                             irObj=geoList$ir$all,\n                             dmObj=geoList$dm$all,\n                             pIndex=indexList$all,\n                             geoSplit=geoSplit)\n  \n  ## Build Mixed weighted\n  \n  if(!geoSplit){\n    \n    mixDataWgt <- mixData\n    \n  } else {\n    \n    mixDataWgt <- prrAggrMethData(mmObj=geoList$mm$all,\n                                  irObj=geoList$ir$all,\n                                  dmObj=geoList$dm$all,\n                                  pIndex=indexList$all,\n                                  geoSplit=geoSplit,\n                                  wgt=TRUE)\n  }\n  \n  ## Build Unit specific\n  \n  # Calculate separate dataset for house and units\n  houseData <- prrAggrMethData(mmObj=geoList$mm$house,\n                               irObj=geoList$ir$house,\n                               dmObj=geoList$dm$house,\n                               pIndex=indexList$house,\n                               geoSplit=geoSplit)\n  unitData <- prrAggrMethData(mmObj=geoList$mm$unit,\n                              irObj=geoList$ir$unit,\n                              dmObj=geoList$dm$unit,\n                              pIndex=indexList$unit,\n                              geoSplit=geoSplit)\n  \n  # Add labels\n  houseData$comp$use <- 'House'\n  houseData$diff$use <- 'House'\n  unitData$comp$use <- 'Unit'\n  unitData$diff$use <- 'Unit'\n  \n  # combine\n  useData <- list(comp=rbind(houseData$comp,\n                             unitData$comp),\n                  diff=rbind(houseData$diff,\n                             unitData$diff))\n  \n  ## Build unit specific weighted\n  \n  if(!geoSplit){\n    \n    useWgt <- prrWeightUses(houseData, unitData, geoList, \n                            pIndex=indexList$all, \n                            geoSplit=geoSplit) \n  } else {\n    \n   \n   # Calculate separate dataset for house and units\n  houseDataW <- prrAggrMethData(mmObj=geoList$mm$house,\n                                irObj=geoList$ir$house,\n                                dmObj=geoList$dm$house,\n                                pIndex=indexList$house,\n                                geoSplit=geoSplit,\n                                wgt=TRUE)\n  unitDataW <- prrAggrMethData(mmObj=geoList$mm$unit,\n                               irObj=geoList$ir$unit,\n                               dmObj=geoList$dm$unit,\n                               pIndex=indexList$unit,\n                               geoSplit=geoSplit,\n                               wgt=TRUE)\n  \n  # Add labels\n  houseDataW$comp$use <- 'House'\n  houseDataW$diff$use <- 'House'\n  unitDataW$comp$use <- 'Unit'\n  unitDataW$diff$use <- 'Unit'\n  \n  # Calculate use specific data\n  useWgt <- prrWeightUses(houseDataW, unitDataW, geoList, \n                          pIndex=indexList$all, geoSplit=TRUE)  \n  }\n  \n  return(list(mix=mixData,\n              mixWgt=mixDataWgt,\n              use=useData,\n              useWgt=useWgt))\n  \n}\n\n## Function to aggregate different method's data -----------------------------------------\n\nprrAggrMethData <- function(mmObj,          # Med Meth obj from prrStsGeoWrap\n                            irObj,          # Cross Reg obj from spaceTimeShard()\n                            dmObj,          # Match obj from spaceTimeShard()\n                            pIndex,         # A price index at the time scale\n                            wgt=FALSE,      # weight based observations\n                            geoSplit=FALSE  # is not all geo areas\n){  \n  \n  ## Isolate the correct data from each object\n  \n#   if(geoSplit){\n    mmDF <- mmObj$stsDF[,c('timeName', 'spaceName', 'yield')]\n#   } else {\n#     mmDF <- mmObj$stsDF[ ,c('timeName', 'yield')]\n#     mmDF$spaceName <- 'all'\n#   }\n    \n  irDF <- irObj$stsDF\n  dmDF <- dmObj$stsDF\n  names(irDF)[2] <- names(dmDF)[2] <- 'yield'\n  \n  ## Determine the spatial areas that exist in all objects  \n  \n  # Extract space from each\n  mmGeo <- levels(mmDF$spaceName)\n  irGeo <- levels(as.factor(irDF$spaceName))\n  dmGeo <- levels(as.factor(dmDF$spaceName))\n  \n  # Determine intersect and limit to that\n  allGeo <- intersect(intersect(mmGeo, irGeo),dmGeo)\n  mmDF <- subset(mmDF, mmDF$spaceName %in% allGeo)\n  irDF <- subset(irDF, irDF$spaceName %in% allGeo)\n  dmDF <- subset(dmDF, dmDF$spaceName %in% allGeo)\n  \n  ## Extract counting parameters\n  \n  oLng <- nrow(mmDF)\n  tLng <- length(unique(mmDF$timeName))\n  \n  ## Build the comparison data set\n  \n  # if not weighted\n  if(!wgt){\n    \n    comData <- rbind(mmDF, irDF, dmDF)\n    comData$method <- c(rep('Median', oLng), rep('Impute', oLng),\n                        rep('Match', oLng))\n    \n  } else {\n    \n    # Weights Tables\n    mmPrice <- mmObj$priceStsTable[rownames(mmObj$priceStsTable) %in% allGeo,]\n    mmRent <- mmObj$rentStsTable[rownames(mmObj$rentStsTable) %in% allGeo,]\n    mmWgts <- prrConvStsTables(mmPrice + mmRent, allGeo)$wgts\n    irWgts <- prrConvStsTables(irObj$stTable, allGeo)$wgts\n    dmWgts <- prrConvStsTables(dmObj$stTable, allGeo)$wgts\n    \n    # Add weights to DF \n    mmDF$wgt <- mmWgts[match(mmDF$spaceName, names(mmWgts))]  \n    irDF$wgt <- irWgts[match(irDF$spaceName, names(irWgts))]  \n    dmDF$wgt <- dmWgts[match(dmDF$spaceName, names(dmWgts))]  \n    \n    # calc weighted yield components\n    mmDF$wYield <- mmDF$yield * mmDF$wgt\n    irDF$wYield <- irDF$yield * irDF$wgt\n    dmDF$wYield <- dmDF$yield * dmDF$wgt\n    \n    # sum to weighted yield\n    mmYields <- tapply(mmDF$wYield, mmDF$timeName, sum)\n    irYields <- tapply(irDF$wYield, irDF$timeName, sum)\n    dmYields <- tapply(dmDF$wYield, dmDF$timeName, sum)\n    \n    # combine together for weighted data\n    comData <- data.frame(timeName=rep(1:tLng, 3),\n                          spaceName=rep('all', 3*tLng),\n                          yield = c(mmYields, irYields, dmYields),\n                          method=c(rep('Median', tLng), rep('Impute', tLng),\n                                   rep('Match', tLng)))\n    \n    # create the dif data inputs\n    mmDF <- comData[comData$method == 'Median', ]\n    irDF <- comData[comData$method == 'Impute', ]\n    dmDF <- comData[comData$method == 'Match', ]\n    oLng <- tLng\n    \n  }\n  \n  # Re-orders levels\n  comData$method <- factor(comData$method,\n                           levels=c('Median', 'Impute', 'Match'))\n  \n  ## Build the differences dataset\n  \n  difData <- rbind(mmDF, irDF, dmDF)\n  difData$pIndex <- rep(pIndex, 3)\n  difData$yield <- NULL\n  difData$method <- c(rep('Impute - Median', oLng),\n                      rep('Match - Median', oLng),\n                      rep('Match - Impute', oLng))\n  difData$dif <- c(irDF$yield - mmDF$yield,\n                   dmDF$yield - mmDF$yield,\n                   dmDF$yield - irDF$yield)\n  \n  # Re-order levels\n  difData$method <- factor(difData$method,\n                           levels=c('Impute - Median', 'Match - Median',\n                                    'Match - Impute'))\n  \n  ## Return data\n  return(list(comp = comData,\n              diff = difData))\n}\n\n### Function that calculates locations count weights -------------------------------------\n\nprrConvStsTables <- function(stTable,       # stsTable from stsSharder\n                             allGeo         # List of OK geographies\n){\n  \n  stTable <- as.data.frame(stTable)\n  \n  stTable <- stTable[rownames(stTable) %in% allGeo, ]\n  \n  stSums <- rowSums(stTable)\n  \n  stWgts <- stSums / sum(stSums)\n  \n  return(list(sums=stSums,\n              wgts=stWgts))\n}\n\n### Function that combines and weights house and unit results ----------------------------\n\nprrWeightUses <- function(hDataW,       # House wgt data from prrAggrMethData\n                          uDataW,       # unit wgt data from prrAggrMethData\n                          geoList,      # Full geolist from  prrAggrGeoData\n                          pIndex,       # Price time index\n                          geoSplit=F    # is not all areas?\n                               \n){  \n  \n  ## Calculate house vs unit weights\n  if(geoSplit){\n    \n  # Find acceptable geos\n    mmHPrice <- geoList$mm$house$priceStsTable\n    mmHRent <- geoList$mm$house$rentStsTable\n    mmUPrice <- geoList$mm$unit$priceStsTable\n    mmURent <- geoList$mm$unit$rentStsTable\n  \n    irHTable <- geoList$ir$house$stTable\n    irUTable <- geoList$ir$unit$stTable\n\n    dmHTable <- geoList$dm$house$stTable\n    dmUTable <- geoList$dm$unit$stTable\n  \n  # Combine all GeoNames  \n    allGeos <- c(rownames(mmHPrice), rownames(mmHRent), rownames(mmUPrice), \n                rownames(mmURent), rownames(irHTable), rownames(irUTable),\n                rownames(dmHTable), rownames(dmUTable))\n    geoNames <- names(table(allGeos))\n    geoTable <- as.numeric(table(allGeos))\n    \n  # Choose those present in all situations  \n    allGeos <- geoNames[which(geoTable == 8)]\n    mmHPrice <- mmHPrice[rownames(mmHPrice) %in% allGeos, ]\n    mmHRent <- mmHRent[rownames(mmHRent) %in% allGeos, ]\n    mmUPrice <- mmUPrice[rownames(mmUPrice) %in% allGeos, ]\n    mmURent <- mmURent[rownames(mmURent) %in% allGeos, ]\n    irHTable <- irHTable[rownames(irHTable) %in% allGeos, ]\n    irUTable <- irUTable[rownames(irUTable) %in% allGeos, ]\n    dmHTable <- dmHTable[rownames(dmHTable) %in% allGeos, ]\n    dmUTable <- dmUTable[rownames(dmUTable) %in% allGeos, ]\n  \n  } else {\n    \n  # Or select all geos if !geoSplit  \n    mmHPrice <- geoList$mm$house$priceStsTable\n    mmHRent <- geoList$mm$house$rentStsTable\n    mmUPrice <- geoList$mm$unit$priceStsTable\n    mmURent <- geoList$mm$unit$rentStsTable\n    \n    irHTable <- geoList$ir$house$stTable\n    irUTable <- geoList$ir$unit$stTable\n    \n    dmHTable <- geoList$dm$house$stTable\n    dmUTable <- geoList$dm$unit$stTable\n  }\n  \n  # Median method\n  \n  mmHwgt <- (sum(mmHPrice + mmHRent)) / (sum(mmHPrice + mmHRent) +\n                                           sum(mmUPrice + mmURent))\n  mmUwgt <- 1-mmHwgt\n  \n  # Impute method\n  irHwgt <- sum(irHTable) / (sum(irHTable + irUTable))  \n  irUwgt <- 1-irHwgt\n  \n  # Match Method\n  dmHwgt <- sum(dmHTable) / (sum(dmHTable + dmUTable))  \n  dmUwgt <- 1-dmHwgt\n  \n  # Combine weights\n  hWgts <- c(rep(mmHwgt, 20), rep(irHwgt, 20), rep(dmHwgt, 20))\n  uWgts <- c(rep(mmUwgt, 20), rep(irUwgt, 20), rep(dmUwgt, 20))\n  \n  ## Build comp data\n  \n  compData <- hDataW$comp\n  compData$yield <- ((hDataW$comp$yield * hWgts) + \n                       (uDataW$comp$yield * uWgts))\n  compData$use <- NULL\n  \n  # Re-order levels\n  compData$method <- factor(compData$method,\n                            levels=c('Median', 'Impute', 'Match'))\n  \n  ## Build difference data\n  \n  difData <- compData\n  oLng <- 20\n  difData$pIndex <- rep(pIndex, 3)\n  difData$yield <- NULL\n  difData$method <- c(rep('Impute - Median', oLng),\n                      rep('Match - Median', oLng),\n                      rep('Match - Impute', oLng))\n  mmDF <- subset(compData, method=='Median')\n  irDF <- subset(compData, method=='Impute')\n  dmDF <- subset(compData, method=='Match')\n  difData$dif <- c(irDF$yield - mmDF$yield,\n                   dmDF$yield - mmDF$yield,\n                   dmDF$yield - irDF$yield)\n  \n  # Re-order levels\n  difData$method <- factor(difData$method,\n                           levels=c('Impute - Median', 'Match - Median',\n                                    'Match - Impute'))\n  \n  ## Return values  \n  \n  return(list(comp=compData,\n              diff=difData))    \n}\n\n### Extract yields from a prrObject ------------------------------------------------------\n\nprrGetYields <- function(prrObj     # Object from the prrAggrGeoData()\n                         ){\n  # Extract mixed yields\n  mixYields <- prrObj$mix$comp\n  \n  # conver to a list\n  mix <- list(median=subset(mixYields, method=='Median'),\n              impute=subset(mixYields, method=='Impute'),\n              match=subset(mixYields, method=='Match'))\n  \n  # Extract house only yields\n  houseYields <- subset(prrObj$use$comp, use=='House')\n  \n  # Convert to a list\n  house <- list(median=subset(houseYields, method=='Median'),\n                impute=subset(houseYields, method=='Impute'),\n                match=subset(houseYields, method=='Match'))\n  \n  # Extract unit only yields\n  unitYields <- subset(prrObj$use$comp, use=='Unit')\n  \n  # Convert to a list\n  unit <- list(median=subset(unitYields, method=='Median'),\n               impute=subset(unitYields, method=='Impute'),\n               match=subset(unitYields, method=='Match'))\n  \n  # Return values\n  return(list(mix=mix,\n              house=house,\n              unit=unit))\n  \n}\n\n### Wrapper to calculate the predictive accuracty of various yield trends ----------------\n\nprrPredModelWrap <- function(dmData,              # matched dataset\n                             yieldData,           # yield data from prrGetYields()\n                             byUse=FALSE,         # Calculate by use?\n                             byGeog=FALSE,        # Calculate by Geography\n                             geoField=NULL        # Which field is the geog name in?\n                             ){\n  \n  # Small helper function to count number of observations\n  geoCount <- function(x){nrow(rbind.fill(x))}\n  \n  # Error catch if no geoField is specified but it is needed\n  if(byGeog & is.null(geoField)) return(cat('Must specify geoField'))\n  \n ## If calculating by use  \n  \n  if(byUse){\n    \n    # Subset house and unit data\n    hData <- subset(dmData, PropertyType == 'House')\n    uData <- subset(dmData, PropertyType == 'Unit')\n    \n    # if calculating by Geography\n    if(byGeog){\n    \n    ## Calculate for Houses\n      \n      # Get geography names and extract necessary data\n      geoListH <- levels(yieldData$house$median$spaceName)\n      geoDataH <- lapply(geoListH, prrExtractGeoData, xData=hData, \n                         geoField=geoField)\n      \n      # Identify non-empty dataset (by geog)\n      hCount <- unlist(lapply(geoDataH, nrow))\n      idH <- which(hCount > 0)\n      \n      # Extract necessary geographic yield information\n      geoYieldsH <- lapply(geoListH, prrExtractGeoYields, yieldData=yieldData$house)\n      \n      # Identify non-empty dataset (by geog)\n      idYH <- lapply(geoYieldsH, geoCount)\n      idYH <- which(idYH > 0)\n      \n      # Select those that meet both criteria\n      idH <- intersect(idH, idYH)\n      \n      # Trim data to those that are not empty\n      geoDataH <- geoDataH[idH]\n      geoYieldsH <- geoYieldsH[idH]\n      \n      # Estimate the prediction error  \n      geoH <- mapply(prrErrorByMethod, mData=geoDataH, yieldData=geoYieldsH)\n      \n      # Combine and rename results\n      hResults <- rbind.fill(geoH)\n      hResults$use <- 'house'\n      hResults$geog <- geoField\n      \n    ## Calculate for units  \n      \n      # Geo geography names and extract necessary data\n      geoListU <- levels(yieldData$unit$median$spaceName)\n      geoDataU <- lapply(geoListU, prrExtractGeoData, xData=uData, \n                         geoField=geoField)\n      \n      # Identify non-empty datasets (by geog)\n      uCount <- unlist(lapply(geoDataU, nrow))\n      idU <- which(uCount > 0)\n      \n      # Extract necessary geographic yield information\n      geoYieldsU <- lapply(geoListU, prrExtractGeoYields, yieldData=yieldData$unit)\n      \n      # Identify non-empty dataset (by geog)\n      idYU <- lapply(geoYieldsU, geoCount)\n      idYU <- which(idYU > 0)\n      \n      # Select those that meet both criteria\n      idU <- intersect(idU, idYU)\n      \n      # Trim data to those that are not empty\n      geoDataU <- geoDataU[idU]\n      geoYieldsU <- geoYieldsU[idU]\n      \n      # Estimate the prediction error  \n      geoU <- mapply(prrErrorByMethod, mData=geoDataU, yieldData=geoYieldsU)\n      \n      # Combine and rename results\n      uResults <- rbind.fill(geoU)\n      uResults$use <- 'unit'\n      uResults$geog <- geoField\n      \n    ## Merge house and unit results\n      \n      xResults <- rbind(hResults, uResults)\n      \n    } else {\n      \n     ## if by Use by not geog  \n      \n      # Calculate errors for houses\n      hResults <- prrErrorByMethod(hData, yieldData$house)\n      hResults <- rbind.fill(hResults)\n      hResults$use <- 'house'\n      \n      # Calculate errors for units\n      uResults <- prrErrorByMethod(uData, yieldData$unit)\n      uResults <- rbind.fill(uResults)\n      uResults$use <- 'unit'\n      \n      # Combine results\n      xResults <- rbind(hResults, uResults)\n      xResults$geog <- 'all'\n    }\n  } else {\n    \n  ## if not by Use by by Geography\n    \n    if(byGeog){\n      \n      # Extract relevant geography names\n      geoList <- levels(yieldData$mix$median$spaceName)\n      \n      # Extract geographic base data\n      geoData <- lapply(geoList, prrExtractGeoData, xData=dmData, \n                        geoField=geoField)\n      \n      # Extract yield trends\n      geoYields <- lapply(geoList, prrExtractGeoYields, yieldData=yieldData$mix)\n      \n      # Calculate all errors\n      geo <- mapply(prrErrorByMethod, mData=geoData, yieldData=geoYields)\n      xResults <- rbind.fill(geo)\n      xResults$geog <- geoField\n      \n    } else {\n      \n  ## If not by use and not by Geography\n      \n      # Calculate error results\n      xResults <- prrErrorByMethod(dmData, yieldData$mix)\n      xResults <- rbind.fill(xResults)\n      xResults$geog <- 'all'\n    }\n    xResults$use <- 'mix'\n  }\n  \n  \n  # Return Values  \n  return(list(median=subset(xResults, method=='median'),\n              impute=subset(xResults, method=='impute'),\n              match=subset(xResults, method=='match')))  \n}\n\n### Helper function to extract geographic from a given dataset ---------------------------\n\nprrExtractGeoData <- function(geoName,      # Specific geographic name\n                              xData,        # dataset \n                              geoField      # Field containing geographic names\n                              ){\n  \n  # ID and extract field\n  gData <- xData[ ,geoField]\n  \n  # Label matching rows\n  idx <- which(gData == geoName)\n  \n  # Return Values\n  return(xData[idx, ])\n  \n}\n\n### Helper function to extract the three yield types for a given geography ---------------\n\nprrExtractGeoYields <- function(geoName,      # A specific geographic name \n                                yieldData     # yield data from prrGetYields()$mix\n                                ){\n  \n  # Extract yields\n  gMedian <- subset(yieldData$median, spaceName==geoName)\n  gImpute <- subset(yieldData$impute, spaceName==geoName)\n  gMatch <- subset(yieldData$match, spaceName==geoName)\n  \n  # Return Values\n  return(list(median=gMedian,\n              impute=gImpute,\n              match=gMatch))\n  \n}\n\n### Wrapper to spread the error calcs over all three methods -----------------------------\n\nprrErrorByMethod <- function(mData,       # Matched dataset\n                             yieldData    # List of yield data from prrGetYields\n                             ){\n  \n  # Calc error for median method\n  medianError <- prrCalcPredError(mData, yieldData$median)\n  medianError$method='median'\n  \n  # Calc error for imputation method\n  imputeError <- prrCalcPredError(mData, yieldData$impute)\n  imputeError$method='impute'\n  \n  # calc error for matching method\n  matchError <- prrCalcPredError(mData, yieldData$match)\n  matchError$method='match'\n  \n  # Return Values\n  return(list(median=medianError,\n              impute=imputeError,\n              match=matchError))\n  \n}\n\n### calculate the predictive error -------------------------------------------------------\n\nprrCalcPredError <- function(mData,     # Dataset of matched sales and rentals \n                             yData      # Timeseries of yield estimates\n                             ){\n  \n  # Subset into sales and rentals based on which observation is first\n  sData <- subset(mData, saleTime <= rentTime)\n  rData <- subset(mData, saleTime > rentTime)\n  sData$tType <- 'sale'\n  rData$tType <- 'rent'\n  \n  # Add the yield information at the time of the first transaction\n  sData$pYield <- yData$yield[match(sData$rentTime, yData$timeName)]  \n  rData$pYield <- yData$yield[match(rData$saleTime, yData$timeName)]  \n  \n  # Predict rental value of sales and the error\n  sData$pValue <- ((sData$adjSale * sData$pYield) / 52) \n  sData$error <- (sData$rentValue - sData$pValue) / sData$rentValue\n\n  # Precict sale value of rentals and the error    \n  rData$pValue <- (rData$adjRent * 52) / rData$pYield\n  rData$error <- (rData$saleValue - rData$pValue) / rData$saleValue\n \n  # Merge data together  \n  xData <- rbind(sData[,c('uID', 'tType', 'error')],\n                 rData[,c('uID', 'tType', 'error')])\n  \n  # Return values\n  return(xData)\n}\n\n\n\n",
    "created" : 1456289367528.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2132796479",
    "id" : "42556270",
    "lastKnownWriteTime" : 1456289522,
    "path" : "~/Documents/R_Workspace/ausPropMrkt/prrFunctions.R",
    "project_path" : "prrFunctions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}